import { Reflection, or, Cache, LRUCache, cacheCommonExpressions, cacheSubjectExpressions, Key } from "@ecchi-js/core";

interface Member {
  $type: "Member";
  id: number;
  name: string;
  email: string;
  moderatorFor: Forum[];
  memberFor: Forum[];
}
interface Environment {
  $type: "Environment";
  owner: Member;
}
interface Forum {
  $type: "Forum";
  id: number;
  name: string;
  tags: string[];
  description: string;
}
interface Topic {
  $type: "Topic";
  id: number;
  title: string;
  forum: Forum;
  author: Member;
}
interface Post {
  $type: "Post";
  id: number;
  title: string;
  content: string;
  author: Member;
  createdAt: number;
  topic: Topic;
}

export type $Types = {
  Member: Member,
  Environment: Environment,
  Forum: Forum,
  Topic: Topic,
  Post: Post,
}

export const $Reflection = new Reflection<$Types>({
  Member: [0,  1],
  Environment: [2,  3],
  Forum: [4,  5],
  Topic: [6,  7],
  Post: [8,  9],
});

export type $UserType = Member;


export type $Role = 'admin'|'moderator'|'registered'|'guest';
export type $Subject = 'member'|'forum'|'topic'|'post';
export type $Subjects = {
  member: Member;
  forum: Forum;
  topic: Topic;
  post: Post;
};
export type $Actions = {
  member: 'update'|'show_profile'|'follow_member'|'subscribe_forum';
  forum: 'create'|'read'|'update'|'delete';
  topic: 'create'|'read'|'update'|'delete';
  post: 'create'|'read'|'update'|'delete';
};

export type CanOptions = {
  I: $UserType;
  actingAs?: $Role[];
  cache?: Cache<Key, any>;
} & ({
  when: 'member';
  subject: Member;
  doWhat: $Actions['member'];
} |  {
  when: 'forum';
  subject: Forum;
  doWhat: $Actions['forum'];
} |  {
  when: 'topic';
  subject: Topic;
  doWhat: $Actions['topic'];
} |  {
  when: 'post';
  subject: Post;
  doWhat: $Actions['post'];
});

const DefaultCache = new LRUCache<Key, any>(128);

export function can({
  I: user,
  actingAs = [],
  when,
  subject,
  doWhat,
  cache = DefaultCache
}: CanOptions) {
  type Common = readonly [null, null, boolean, boolean, Member, Forum[], Forum[]];
  const commonExpressions = cacheCommonExpressions<Common>([
    (): null => null,
    (): null => null,
    (): boolean => true,
    (): boolean => false,
    (): Member => user,
    (commons): Forum[] => commons[4].memberFor,
    (commons): Forum[] => commons[4].moderatorFor
  ] as const, [user], cache);

  const subjectHandlers: { [K in $Subject]: (subject: $Subjects[K]) => boolean} = {
    member(subject: Member) {
      type Subject = readonly [null, Member, boolean, boolean];
      const subjectExpressions = cacheSubjectExpressions<Common, Subject>(commonExpressions, [
        (): null => null,
        (): Member => subject,
        (commons, subjects): boolean => commons[4] == subjects[1],
        (commons, subjects): boolean => commons[2] && subjects[2]
      ] as const, [subject], cache);
      const actionBits = {
        update: {
          allow: [0, 1 << 0],
          forbid: [0, 1 << 1],
        },
        show_profile: {
          allow: [0, 1 << 2],
          forbid: [0, 1 << 3],
        },
        follow_member: {
          allow: [0, 1 << 4],
          forbid: [0, 1 << 5],
        },
        subscribe_forum: {
          allow: [0, 1 << 6],
          forbid: [0, 1 << 7],
        },
      };
      const roleHandlers: Record<$Role, (() => [boolean, number[]])[]> = {
        admin: [
          () => [commonExpressions[2], [0x55]]
        ],
        moderator: [
          () => [subjectExpressions[3], [0x51]],
          () => [commonExpressions[2], [0x04]]
        ],
        registered: [
          () => [subjectExpressions[3], [0x51]],
          () => [commonExpressions[2], [0x04]]
        ],
        guest: [
          () => [commonExpressions[2], [0xAA]]
        ],
      };
      const { allow, forbid } = actionBits[doWhat];
      const mask = actingAs.flatMap(role => roleHandlers[role])
        .map(item => item())
        .filter(([condition, _]) => condition)
        .map(([_, mask]) => mask)
        .reduce((lhs, rhs) => or(lhs, rhs));
      return mask.length > 0
        && (mask[forbid[0]] & forbid[1]) === 0
        && (mask[allow[0]] & allow[1]) !== 0;
    },
    forum(subject: Forum) {
      type Subject = readonly [null, Forum, boolean, boolean, boolean, boolean];
      const subjectExpressions = cacheSubjectExpressions<Common, Subject>(commonExpressions, [
        (): null => null,
        (): Forum => subject,
        (commons, subjects): boolean => commons[5].includes(subjects[1]),
        (commons, subjects): boolean => commons[2] && subjects[2],
        (commons, subjects): boolean => commons[6].includes(subjects[1]),
        (commons, subjects): boolean => commons[2] && subjects[4]
      ] as const, [subject], cache);
      const actionBits = {
        create: {
          allow: [0, 1 << 0],
          forbid: [0, 1 << 1],
        },
        read: {
          allow: [0, 1 << 2],
          forbid: [0, 1 << 3],
        },
        update: {
          allow: [0, 1 << 4],
          forbid: [0, 1 << 5],
        },
        delete: {
          allow: [0, 1 << 6],
          forbid: [0, 1 << 7],
        },
      };
      const roleHandlers: Record<$Role, (() => [boolean, number[]])[]> = {
        admin: [
          () => [commonExpressions[2], [0x55]]
        ],
        moderator: [
          () => [subjectExpressions[3], [0x04]],
          () => [subjectExpressions[5], [0x51]]
        ],
        registered: [
          () => [subjectExpressions[3], [0x04]]
        ],
        guest: [
          () => [commonExpressions[2], [0x04]],
          () => [commonExpressions[2], [0xA2]]
        ],
      };
      const { allow, forbid } = actionBits[doWhat];
      const mask = actingAs.flatMap(role => roleHandlers[role])
        .map(item => item())
        .filter(([condition, _]) => condition)
        .map(([_, mask]) => mask)
        .reduce((lhs, rhs) => or(lhs, rhs));
      return mask.length > 0
        && (mask[forbid[0]] & forbid[1]) === 0
        && (mask[allow[0]] & allow[1]) !== 0;
    },
    topic(subject: Topic) {
      type Subject = readonly [null, Topic, Forum, boolean, boolean, boolean, boolean, Member, boolean, boolean];
      const subjectExpressions = cacheSubjectExpressions<Common, Subject>(commonExpressions, [
        (): null => null,
        (): Topic => subject,
        (_common, subjects): Forum => subjects[1].forum,
        (commons, subjects): boolean => commons[6].includes(subjects[2]),
        (commons, subjects): boolean => commons[2] && subjects[3],
        (commons, subjects): boolean => commons[5].includes(subjects[2]),
        (commons, subjects): boolean => commons[2] && subjects[5],
        (_common, subjects): Member => subjects[1].author,
        (commons, subjects): boolean => subjects[7] == commons[4],
        (commons, subjects): boolean => commons[2] && subjects[8]
      ] as const, [subject], cache);
      const actionBits = {
        create: {
          allow: [0, 1 << 0],
          forbid: [0, 1 << 1],
        },
        read: {
          allow: [0, 1 << 2],
          forbid: [0, 1 << 3],
        },
        update: {
          allow: [0, 1 << 4],
          forbid: [0, 1 << 5],
        },
        delete: {
          allow: [0, 1 << 6],
          forbid: [0, 1 << 7],
        },
      };
      const roleHandlers: Record<$Role, (() => [boolean, number[]])[]> = {
        admin: [
          () => [commonExpressions[2], [0x55]]
        ],
        moderator: [
          () => [subjectExpressions[4], [0x55]]
        ],
        registered: [
          () => [subjectExpressions[6], [0x05]],
          () => [subjectExpressions[9], [0x10]]
        ],
        guest: [
          () => [commonExpressions[2], [0x04]],
          () => [commonExpressions[2], [0xA2]]
        ],
      };
      const { allow, forbid } = actionBits[doWhat];
      const mask = actingAs.flatMap(role => roleHandlers[role])
        .map(item => item())
        .filter(([condition, _]) => condition)
        .map(([_, mask]) => mask)
        .reduce((lhs, rhs) => or(lhs, rhs));
      return mask.length > 0
        && (mask[forbid[0]] & forbid[1]) === 0
        && (mask[allow[0]] & allow[1]) !== 0;
    },
    post(subject: Post) {
      type Subject = readonly [null, Post, Topic, Forum, boolean, boolean, boolean, boolean, Member, boolean, boolean];
      const subjectExpressions = cacheSubjectExpressions<Common, Subject>(commonExpressions, [
        (): null => null,
        (): Post => subject,
        (_common, subjects): Topic => subjects[1].topic,
        (_common, subjects): Forum => subjects[2].forum,
        (commons, subjects): boolean => commons[6].includes(subjects[3]),
        (commons, subjects): boolean => commons[2] && subjects[4],
        (commons, subjects): boolean => commons[5].includes(subjects[3]),
        (commons, subjects): boolean => commons[2] && subjects[6],
        (_common, subjects): Member => subjects[1].author,
        (commons, subjects): boolean => subjects[8] == commons[4],
        (commons, subjects): boolean => commons[2] && subjects[9]
      ] as const, [subject], cache);
      const actionBits = {
        create: {
          allow: [0, 1 << 0],
          forbid: [0, 1 << 1],
        },
        read: {
          allow: [0, 1 << 2],
          forbid: [0, 1 << 3],
        },
        update: {
          allow: [0, 1 << 4],
          forbid: [0, 1 << 5],
        },
        delete: {
          allow: [0, 1 << 6],
          forbid: [0, 1 << 7],
        },
      };
      const roleHandlers: Record<$Role, (() => [boolean, number[]])[]> = {
        admin: [
          () => [commonExpressions[2], [0x55]]
        ],
        moderator: [
          () => [subjectExpressions[5], [0x55]]
        ],
        registered: [
          () => [subjectExpressions[7], [0x05]],
          () => [subjectExpressions[10], [0x50]]
        ],
        guest: [
          () => [commonExpressions[2], [0x04]],
          () => [commonExpressions[2], [0xA2]]
        ],
      };
      const { allow, forbid } = actionBits[doWhat];
      const mask = actingAs.flatMap(role => roleHandlers[role])
        .map(item => item())
        .filter(([condition, _]) => condition)
        .map(([_, mask]) => mask)
        .reduce((lhs, rhs) => or(lhs, rhs));
      return mask.length > 0
        && (mask[forbid[0]] & forbid[1]) === 0
        && (mask[allow[0]] & allow[1]) !== 0;
    },
  };
  return subjectHandlers[when](subject as any);
}
